<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Personal website of Roman Böhm. Includes blog posts, shorter 'Today I learned' posts, and various personal information."><meta name=viewport content="width=device-width,initial-scale=1"><link href=/css/stylesheet.css rel=stylesheet><title>Roman Böhm - Keep Your Properties Close, but Your @TestConfiguration Closer - Selected Spring Boot Testing Tips</title></head><body><h1>Roman Böhm</h1><nav><ul class=menu><li><a href=/>Home</a></li><li><a href=/posts/>Posts</a></li><li><a href=/til/>TIL</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li><li><a href=/index.xml><img src=/images/rss.svg alt="RSS icon" width=14em></a></li></ul></nav><hr><h1>Keep Your Properties Close, but Your @TestConfiguration Closer - Selected Spring Boot Testing Tips</h1><h2>2021-10-02</h2><h4>Last edit: 2023-06-02</h4><b><a href=/tags/spring-boot>spring-boot</a></b>
<b><a href=/tags/spring>spring</a></b>
<b><a href=/tags/testing>testing</a></b><aside><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#keep-configuration-close-to-the-tests>Keep Configuration Close to the Tests</a><ul><li><a href=#testconfiguration-as-inner-class><code>@TestConfiguration</code> As Inner Class</a></li><li><a href=#properties-declared-at-class-level>Properties Declared At Class Level</a></li></ul></li><li><a href=#dont-dirty-your-context>Don&rsquo;t Dirty Your Context</a></li><li><a href=#use-springboottest-religiously>Use @SpringBootTest religiously</a></li><li><a href=#use-testcontainers>Use Testcontainers</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></aside><h2 id=introduction>Introduction</h2><p>Spring Boot is great and the best thing about it is how easy it makes it to test your application. So here are some selected tips for writing tests with Spring Boot. The most recent stable Spring Boot version at the time of publishing was 2.5.5.</p><h2 id=keep-configuration-close-to-the-tests>Keep Configuration Close to the Tests</h2><p>The configuration and setup of the tests should be as close to them as possible. This reduces the possibility of one test interfering with another and makes it much easier for the reader of the test to grok its purpose.
Here are two means to achieve that goal:</p><h3 id=testconfiguration-as-inner-class><code>@TestConfiguration</code> As Inner Class</h3><p>I often use this one to re-configure beans for a single testsuite only. Like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@DataJpaTest</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StatementCountTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@TestConfiguration</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ProxyDataSourceConfig</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>        DataSource <span style=color:#a6e22e>dataSource</span>(DataSourceProperties baseDataSourceProperties) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> StatementListeningDataSource(
</span></span><span style=display:flex><span>                baseDataSourceProperties.<span style=color:#a6e22e>initializeDataSourceBuilder</span>().<span style=color:#a6e22e>build</span>()
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> EventRepository eventRepository;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>executesSingleStatementToFindAllEvents</span>() {
</span></span><span style=display:flex><span>        StatementCountValidator validator <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StatementCountValidator();
</span></span><span style=display:flex><span>        eventRepository.<span style=color:#a6e22e>findAll</span>(); <span style=color:#75715e>// Uses the `DataSource` implementation provided above internally.</span>
</span></span><span style=display:flex><span>        assertThat(validator.<span style=color:#a6e22e>getStatementCount</span>()).<span style=color:#a6e22e>isEqualTo</span>(1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=properties-declared-at-class-level>Properties Declared At Class Level</h3><p>Tests should be as close to your production environment as possible. Declaring your properties with <code>@SpringBootTest(properties = { "x=y", "n=1" })</code> (same goes for <a href=https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing.spring-boot-applications.autoconfigured-tests>test slices</a>) at the class level helps with that: It allows to</p><ol><li>provide only the needed properties, in case you do not keep properties files, or to</li><li>selectively override individual properties, like URLs, for tests.</li></ol><h2 id=dont-dirty-your-context>Don&rsquo;t Dirty Your Context</h2><p>Sounds like innuendo, but it&rsquo;s supposed to signal something entirely different: Do not use <code>@DirtiesContext</code> to reset your <a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/ApplicationContext.html>ApplicationContext</a> because your test suite will become horribly slow.
Rather reset your state (e.g. database) manually through <code>@AfterEach</code>/<code>@AfterClass</code> or employ other means which allow Spring to <a href=https://rieckpil.de/improve-build-times-with-context-caching-from-spring-test/>cache your context</a>.</p><p>Therefore I&rsquo;d also suggest to &mldr;</p><h2 id=use-springboottest-religiously>Use @SpringBootTest religiously</h2><p>Even though it may seem counter-intuitive at first, try using <code>@SpringBootTest</code> &ldquo;by default&rdquo;. My rule of thumb is: for any unit test where you need to nest your mocks and cannot use a test slice. This provides a lot of advantages in my opinion:</p><ol><li>It makes tests cleaner. An <code>@Autowired</code> is most often much shorter than <code>new ABean(new BBean(MyConfigurationFromSomeWhere()))</code>.</li><li>It&rsquo;s not only cleaner, but the beans in your tests will be set up the same as in your production environment. There&rsquo;s fewer surprises later on in case the way you manually set up your beans, or your mocks does not reflect your production system anymore.</li><li>It may even be faster or as fast as tests with a lot of mocks and spies due to the above mentioned context caching.</li></ol><h2 id=use-testcontainers>Use Testcontainers</h2><p>If you&rsquo;ve never heard of it: <a href=https://www.testcontainers.org/>Testcontainers</a> provides a truly extraordinary library to run your tests against &ldquo;real&rdquo; infrastructure. Your database in your test will be on-par feature-wise with your production database because <em>it&rsquo;s the same database</em> (only running within a Docker container), your Kafka cluster won&rsquo;t be some half-assed in-house in-memory implementation, it&rsquo;ll be the real deal.
I use their Postgres container for my <a href=https://github.com/rmnbhm/wichtelnng>showcase application</a> and it&rsquo;s just a single line to have an actual Postgres database available for my <code>@SpringBootTest</code>s:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-properties data-lang=properties><span style=display:flex><span><span style=color:#75715e># In src/test/resources/config/application.properties</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>spring.datasource.url</span><span style=color:#f92672>=</span><span style=color:#e6db74>jdbc:tc:postgresql:latest:///postgres?TC_DAEMON=true</span>
</span></span></code></pre></div><p>No configuration needed in the tests themselves! Also note the <code>?TC_DAEMON=true</code>. This will keep the container running even without open connections to the database, meaning it&rsquo;ll be available super quickly for the next test.</p><h2 id=conclusion>Conclusion</h2><p>Spring Boot is opinionated and so were these tips. I found by honoring them my tests became easier to read, easier to maintain, and more meaningful, sometimes even faster. When in doubt just measure&mldr; or find what works for you, a fully-featured application context is waiting at your finger tips.</p><hr>© Roman Böhm 2021 - 2024 &ndash; <a href=https://github.com/romanboehm>Github</a> &ndash;
<a rel=me href=https://mastodon.social/@romanboehm>Mastodon</a> &ndash; <a href=https://www.linkedin.com/in/%F0%9F%96%A5%EF%B8%8F-roman-b%C3%B6hm-837946175/>LinkedIn</a></body></html>