<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Personal website of Roman Böhm. Includes blog posts, shorter 'Today I learned' posts, and various personal information."><meta name=viewport content="width=device-width,initial-scale=1"><link href=/css/stylesheet.css rel=stylesheet><title>Roman Böhm - Tell Me Your Environment and I Tell You What Your Context Is</title></head><body><h1>Roman Böhm</h1><nav><ul class=menu><li><a href=/>Home</a></li><li><a href=/posts/>Posts</a></li><li><a href=/til/>TIL</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li><li><a href=/index.xml><img src=/images/rss.svg alt="RSS icon" width=14em></a></li></ul></nav><hr><h1>Tell Me Your Environment and I Tell You What Your Context Is</h1><h2>2022-08-06</h2><h4>Last edit: 2023-06-26</h4><b><a href=/tags/spring>spring</a></b>
<b><a href=/tags/spring-boot>spring-boot</a></b>
<b><a href=/tags/testing>testing</a></b>
<b><a href=/tags/dependencyinjection>dependencyinjection</a></b><aside><nav id=TableOfContents><ul><li><a href=#introduction>Introduction</a></li><li><a href=#the-problem>The Problem</a></li><li><a href=#the-solution>The Solution</a><ul><li><a href=#our-starting-point>Our Starting Point</a></li><li><a href=#conditionality>Conditionality</a></li><li><a href=#asynchrony>Asynchrony</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></aside><h2 id=introduction>Introduction</h2><p>At my previous work we had this problem where we couldn&rsquo;t run through our entire workflow in our integration system because we were missing the necessary input data to some central service&rsquo;s integration instance. We therefore took it upon us to provide said data by asynchronously <em>mirroring</em> data from prod to int.</p><p>This is definitely not a &ldquo;Five tips on how to deal with numbers in JavaScript &ndash; NaN will shock you!&rdquo; or &ldquo;The best Spring annotations of 2021&rdquo; kind of post. There aren&rsquo;t going to be any checklists, best practices, or tips on anything. I just wanted to write down a somewhat elegant solution to a mildly interesting problem.</p><h2 id=the-problem>The Problem</h2><p>We had a service dedicated to source product data from an end-of-life system. Let&rsquo;s call them <em>Legacy Accumulator</em>, or <em>Accumulator</em>, and <em>Legacy Service</em>, respectively. We triggered <em>Accumulator</em> if product data was missing certain pieces of information. You can regard it as some sort of bridge: It brought the data up to the standard we required later on in our context.</p><p>Seems unfortunate enough already, but here&rsquo;s the catch:</p><ul><li><em>Accumulator</em> had a production instance querying <em>Legacy Service</em>&rsquo;s production instance.</li><li><em>Legacy Service</em> did not provide an integration instance of itself. (As is tradition &mldr;)</li><li>Our integration system generally handled copies of production&rsquo;s product data.</li><li>Our integration system should <em>not</em>, however, at any stage query <em>Legacy Service</em>&rsquo;s production instance. We had no business interfering with production systems for our testing needs. We also actually didn&rsquo;t want to query <em>Legacy Service</em> twice because that cost quite a bit of time.</li></ul><h2 id=the-solution>The Solution</h2><p>Our solution was to provide data to integration storage by means of <strong>asynchronously mirroring the &ldquo;save to storage&rdquo; calls on production to integration</strong>. Hacky, but it had a few upsides:</p><ol><li>It barely taxed our production instance of <em>Accumulator</em>, and there was no extra load on <em>Legacy Service</em>. Spring picked an idle thread from the pool and gave it a bit of I/O work to handle.</li><li>Using Spring, and building upon a well-designed codebase by my former team, the extra functionality was quite easy to add. Moreover, it would then be quick to get rid of or deactivate. Everything hinged upon two corresponding extra properties being set at application startup, which we could provide through environment variables passed along to the Docker container.</li></ol><h3 id=our-starting-point>Our Starting Point</h3><p>The bean dealing with storage access used to be provided by reading the two necessary properties and calling our storage client library&rsquo;s factory method with them:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Configuration</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StorageConfig</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span>    StorageAccess <span style=color:#a6e22e>storageAccess</span>(
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Value</span>(<span style=color:#e6db74>&#34;${storage.env}) env,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        @Value(&#34;</span>${storage.<span style=color:#a6e22e>pw</span>}) pw,
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Storage.<span style=color:#a6e22e>createStorageAccess</span>(env, pw);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>StorageAccess</code> was an interface with methods like <code>save(ProductData data)</code> and it was <code>@Autowired</code> in a <code>@Service</code> bean of Accumulator, serving the application when persisting product data.</p><h3 id=conditionality>Conditionality</h3><p>In order to keep interference to a minimum we provided the mirroring functionality through an additional conditional bean:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Configuration</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@ConditionalOnProperty</span>({<span style=color:#e6db74>&#34;mirroring.storage.env&#34;</span>, <span style=color:#e6db74>&#34;mirroring.storage.pw&#34;</span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MirroringStorageConfig</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Bean</span>(<span style=color:#e6db74>&#34;mirroringStorageAccess&#34;</span>)
</span></span><span style=display:flex><span>    StorageAccess <span style=color:#a6e22e>mirroringStorageAccess</span>(
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Value</span>(<span style=color:#e6db74>&#34;${mirroring.storage.env}) env,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        @Value(&#34;</span>${mirroring.<span style=color:#a6e22e>storage</span>.<span style=color:#a6e22e>pw</span>}) pw,
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Storage.<span style=color:#a6e22e>createStorageAccess</span>(env, pw);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We could&rsquo;ve left out the qualifier for the bean, but it made it easier to read and less prone to breakage upon refactoring method names. The above mentioned OG <code>StorageAccess</code> also received a qualifier: &ldquo;storageAccess&rdquo;.</p><p>In order to make mirroring transparent at the call-site we chose to provide our own implementation of <code>StorageAccess</code> which delegated its work to the regular storage access implementation for all but one of its operations: Only when calling <code>save(...)</code> it would delegate to the regular storage access instance first <em>and then, asynchronously</em>, to the mirroring storage access:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Component</span>(<span style=color:#e6db74>&#34;saveMirroringStorageAccess&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@ConditionalOnConfiguration</span>(MirroringStorageConfig.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Primary</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SaveMirroringStorageAccess</span> <span style=color:#66d9ef>implements</span> StorageAccess {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;storageAccess&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> StorageAccess primary;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;mirroringStorageAccess&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> StorageAccess mirror;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Product <span style=color:#a6e22e>load</span>(String id) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> primary.<span style=color:#a6e22e>load</span>(id);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// More methods delegated to exclusively primary.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>save</span>(ProductData data) {
</span></span><span style=display:flex><span>        primary.<span style=color:#a6e22e>save</span>(data);
</span></span><span style=display:flex><span>        mirror.<span style=color:#a6e22e>save</span>(data);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>What&rsquo;s neat about that?</p><ol><li>The whole config existed only when mirroring was activated through the two corresponding properties due to <code>@ConditionalOnProperty(...)</code> and <code>@ConditionalOnConfiguration(...)</code>.</li><li>Devs did not have to change call-site code or to even care which implementation to inject. As soon as the properties were set, our mirroring implementation would be the primary one due to what is essentially a conditional <code>@Primary</code> bean.</li></ol><p>To be on the safe side we added a test, making sure the wiring actually worked:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// Set basic common properties to get application started.</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@TestPropertySource</span>(properties <span style=color:#f92672>=</span> { <span style=color:#e6db74>&#34;accumulator.foo=1&#34;</span>, <span style=color:#e6db74>&#34;accumulator.bar=2&#34;</span> })
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StorageAccessTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Nested</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SpringBootTest</span>(properties <span style=color:#f92672>=</span> { storage.<span style=color:#a6e22e>env</span><span style=color:#f92672>=</span>test, storage.<span style=color:#a6e22e>pw</span><span style=color:#f92672>=</span>mypass })
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RegularStorageAccess</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> StorageAccess storageAccess;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>providesRegularStorageAccess</span>() {
</span></span><span style=display:flex><span>            assertThat(storageAccess).<span style=color:#a6e22e>isInstanceOf</span>(StorageAccessImpl.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Nested</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SpringBootTest</span>(properties <span style=color:#f92672>=</span> { 
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;storage.env=test&#34;</span>, 
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;storage.pw=mypass&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;mirroring.storage.env=mirror&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;mirroring.storage.pw=mymirrorpass&#34;</span>
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MirrorStorageAccess</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> StorageAccess storageAccess;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>providesSaveMirroringStorageAccessIfPropertiesAreProvided</span>() {
</span></span><span style=display:flex><span>            assertThat(storageAccess).<span style=color:#a6e22e>isInstanceOf</span>(SaveMirroringStorageAccess.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Yes, it&rsquo;s started full blown contexts and tested implementation details, and yes, it bordered on testing framework functionality! But as I said: We did want to be sure our whole context wass still valid &ndash; better safe than sorry.</p><h3 id=asynchrony>Asynchrony</h3><p>What we&rsquo;ve seen above wasn&rsquo;t the whole truth as asynchrony was yet missing from the new implementation. Since Spring has an <code>@Async</code> annotation to make classes or methods asynchronous that should be rather succint, yes? Well, <em>quite</em> succint, since proxying forbade us from just annotating the <code>save</code> method within <code>SaveMirroringStorageAccess</code> &ndash; the async method had to sit in a different class from the call-site.
We achieved that with a wrapping class:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Component</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@ConditionalOnConfiguration</span>(MirroringStorageConfig.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AsyncMirroringWrapper</span> {
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;mirroringStorageAccess&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> StorageAccess mirror;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Async</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>saveAsync</span>(ProductData data) {
</span></span><span style=display:flex><span>        mirror.<span style=color:#a6e22e>save</span>(data);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And injected said wrapper to our <em>delegating</em> <code>StorageAccess</code> version instead:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SaveMirroringStorageAccess</span> <span style=color:#66d9ef>implements</span> StorageAccess {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Qualifier</span>(<span style=color:#e6db74>&#34;storageAccess&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> StorageAccess primary;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The following field used to be the mirroring `StorageAccess` instance.</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> AsyncMirroringWrapper wrapper; 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>save</span>(ProductData data) {
</span></span><span style=display:flex><span>        primary.<span style=color:#a6e22e>save</span>(data);
</span></span><span style=display:flex><span>        wrapper.<span style=color:#a6e22e>saveAsync</span>(data);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Asynchrony might introduce a thousand problems to your code, but in our case the main issue with regards to testing was to make sure the code <em>did actually run async</em> and not block.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@SpringBootTest</span>(properties <span style=color:#f92672>=</span> { 
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;storage.env=test&#34;</span>, 
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;storage.pw=mypass&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;mirroring.storage.env=mirror&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;mirroring.storage.pw=mymirrorpass&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e>// other props</span>
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#a6e22e>@AutoConfigureMockMvc</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SaveMirroringStorageAccessTest</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    prvivate MockMvc mvc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@MockBean</span>(name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;storageAccess&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> StorageAccess primary;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@MockBean</span>(name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;mirroringStorageAccess&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> StorageAccess mirror;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SpyBean</span>(name<span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;saveMirroringStorageAccess&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> StorageAccess combined;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Test</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doesNotBlockWhenMirroring</span>() {
</span></span><span style=display:flex><span>        AtomicBoolean hasMirrored <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> AtomicBoolean(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>        CountDownLatch latch <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> CountDownLatch(1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        doAnswer(inv <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            latch.<span style=color:#a6e22e>await</span>();
</span></span><span style=display:flex><span>            hasMirrored.<span style=color:#a6e22e>compareAndSet</span>(<span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }).<span style=color:#a6e22e>when</span>(mirror).<span style=color:#a6e22e>save</span>(any());
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        mvc.<span style=color:#a6e22e>perform</span>(post(<span style=color:#e6db74>&#34;/&#34;</span>, ...))
</span></span><span style=display:flex><span>            .<span style=color:#a6e22e>andExpect</span>(status().<span style=color:#a6e22e>is2xxSuccessful</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        assertThat(hasMirrored).<span style=color:#a6e22e>isFalse</span>();
</span></span><span style=display:flex><span>        verify(primary, times(1)).<span style=color:#a6e22e>save</span>(any());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        latch.<span style=color:#a6e22e>countDown</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        await().<span style=color:#a6e22e>atMost</span>(1, SECONDS).<span style=color:#a6e22e>untilTrue</span>(hasMirrored);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Again, internal knowledge of how classes were set up, mocking and stubbing within a <code>@SpringBootTest</code>, and other violations of what is good and right. I know&mldr; But that was the price for our feature having minimal impact on existing code. And we chose to pay it. And for testing non-trivial, non-business-logic, async code it reads pretty nicely in my opinion.</p><h2 id=conclusion>Conclusion</h2><p>So much for our unorthodox solution to collecting data for integration testing. Would I recommend it to somebody else? Not if you can avoid it. Was it worth it? I hope so. Can we get rid of it again? Yes, it can be very easily deactivated or even removed without causing a bunch of follow-up patches to code that has been added in the meantime. Is the code easy to follow? I rather think so, thanks to Spring (and JUnit 5, Mockito, and Awaitility).</p><hr>© Roman Böhm 2021 - 2024 &ndash; <a href=https://github.com/romanboehm>Github</a> &ndash;
<a rel=me href=https://mastodon.social/@romanboehm>Mastodon</a> &ndash; <a href=https://www.linkedin.com/in/%F0%9F%96%A5%EF%B8%8F-roman-b%C3%B6hm-837946175/>LinkedIn</a></body></html>